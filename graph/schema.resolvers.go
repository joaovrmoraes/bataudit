package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"

	"github.com/joaovrmoraes/bataudit/graph/model"
)

// Audits is the resolver for the audits field.
func (r *queryResolver) Audits(ctx context.Context, page *int32, limit *int32) (*model.AuditList, error) {
	p := 1
	l := 10
	if page != nil {
		p = int(*page)
	}
	if limit != nil {
		l = int(*limit)
	}
	result, err := r.AuditService.ListAudits(l, (p-1)*l)
	if err != nil {
		return nil, err
	}

	// converter AuditSummary -> model.AuditSummary
	items := make([]*model.AuditSummary, 0, len(result.Data))
	for _, s := range result.Data {
		items = append(items, &model.AuditSummary{
			ID:         s.ID,
			Identifier: s.Identifier,
			UserEmail:  func() *string { v := s.UserEmail; return &v }(),
			UserName:   func() *string { v := s.UserName; return &v }(),
			Method:     string(s.Method),
			Path:       s.Path,
			StatusCode: func() *int32 {
				v := int32(s.StatusCode)
				return &v
			}(),
			ServiceName: s.ServiceName,
			Timestamp:   s.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
			ResponseTime: func() *int32 {
				v := int32(s.ResponseTime)
				return &v
			}(),
		})
	}

	totalPage := int((result.TotalItems + int64(l) - 1) / int64(l))

	return &model.AuditList{
		Data: items,
		Pagination: &model.Pagination{
			Limit:      int32(l),
			Page:       int32(p),
			TotalItems: int32(result.TotalItems),
			TotalPage:  int32(totalPage),
		},
	}, nil
}

// Audit is the resolver for the audit field.
func (r *queryResolver) Audit(ctx context.Context, id string) (*model.Audit, error) {
	a, err := r.AuditService.GetAuditByID(id)
	if err != nil {
		return nil, err
	}
	if a == nil {
		return nil, nil
	}
	return &model.Audit{
		ID:          a.ID,
		Identifier:  a.Identifier,
		UserEmail:   func() *string { v := a.UserEmail; return &v }(),
		UserName:    func() *string { v := a.UserName; return &v }(),
		Method:      string(a.Method),
		Path:        a.Path,
		StatusCode:  func() *int32 { v := int32(a.StatusCode); return &v }(),
		ServiceName: a.ServiceName,
		Timestamp:   a.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
		ResponseTime: func() *int32 {
			v := int32(a.ResponseTime)
			return &v
		}(),
	}, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
